# RabbitMQ

## 一、结构
- ​**生产者**​ (Producer)
- ​**消费者**​ (Consumer)
- ​**Broker**​
    - ​**vhost**​ (虚拟主机)
        - ​**交换机**​ (Exchange)
            - Direct (直连交换机)
            - Topic (主题交换机)
            - Fanout (广播交换机)
            - Headers (头交换机)
        - ​**绑定**​ (Binding)
        - ​**队列**​ (Queue)

---

## 二、特殊队列
- ​**死信队列**​ (Dead Letter Queue)
- ​**优先级队列**​ (Priority Queue)
- ​**惰性队列**​ (Lazy Queue)
    - ​**实现原理**​：消息在被写入队列时就直接持久化到磁盘。当消费者准备消费时，再从磁盘加载到内存。
    - ​**适用场景**​：解决生产速度远大于消费速度的消息积压问题
        - 内存耗尽（Out of Memory）：海量积压的消息会占用大量内存，导致整个 RabbitMQ Broker 内存飙升，触发流量控制（Flow Control），甚至使整个服务器崩溃。
        - 消息换出（Paging）性能骤降：当内存不足时，RabbitMQ 会启动一个名为 "Paging" 的过程，将内存中的消息批量转移到磁盘。这个过程是阻塞性的，会严重消耗 CPU 和磁盘 I/O，导致所有队列（包括其他正常队列）的性能急剧下降，整个系统响应变慢。
    - ​**配置方式**​：
        - RabbitMQ 的管理界面或命令行动态地给队列打上策略标签
        - 声明队列时指定（代码中配置）
        - 在 RabbitMQ 配置文件 rabbitmq.conf 中配置

---

## 三、持久化机制
- ​**交换机持久化**​
    - 若未显式声明，默认交换机是非持久化的（重启后丢失）
        - 需在创建交换机时设置，已有交换机无法修改此属性。若要更改，通常需要删除后重新创建（注意：这会导致该队列或交换机中的消息丢失）
- ​**队列持久化**​
    - 仅队列元数据（名称、属性）持久化，队列中的消息仍需单独配置
        - 需在创建队列时设置，已有队列无法修改此属性
- ​**消息持久化**​
    - 非持久化消息 + 未 ACK，消息保留在内存，消费者断开后可能丢失
        - 消息持久化必须每条消息单独配置（deliveryMode=2）
- ​**持久化代价**​
    - 持久化消息会触发磁盘 I/O，性能比内存操作低 10-100 倍
    - 解决方案：使用 SSD、批量确认

---

## 四、ACK 确认机制
- ​**配置**​
    - 队列级：定义消费者的 autoAck 模式
    - 消息级：针对每条消息执行 basicAck 或 basicNack
- ​**消息级别**​（每条消息独立确认）

---

## 五、架构设计
- ​**主从模式**​ (Master-Slave)
- ​**镜像队列**​ (Mirrored Queues)
- ​**Quorum Queues**​ (仲裁队列)

---

## 六、常见问题

### 1. 顺序消费问题
- ​**方案1：强制串行化**​
    - 单队列 + 单消费者
- ​**方案2：业务ID分片方案**​
    - ​**生产者**​：需要保障顺序消费的消息（同一订单号的所有操作：创建、付款、发货），通过相同 routing key 发送
    - ​**Broker**​：保证相同 routing key 路由到同一个队列
        - 插件方式
            - rabbitmq_sharding 插件
            - rabbitmq_consistent_hash_exchange 插件
        - 常用的自主实现方式
            1. 预先创建好多个队列
            2. 生产者根据业务ID（如 orderId）计算一个哈希值，再通过对队列数取模，自主决定将消息发送到哪个具体的队列
    - ​**消费者**​
        - 设置预取计数 (basicQos(1))：告诉 RabbitMQ 每次只推送一条消息给消费者，直到该消息被确认。这是保证顺序的关键之一，防止一个消费者积压大量消息。
        - 每个队列只有一个消费者
        - 消费失败进入死信队列，不重新入队，同样后续业务消息也要谨慎处理，人工干预日志告警都需要
    - ​**备注**​
        - 吞吐量扩展办法：按组水平增加队列和消费者，保证一一对应
- ​**方案3：聚合处理**​
    - 消息带业务编号，多个具有顺序编号的信息通过业务合并处理，缺点是太复杂，并且业务延迟很高

### 2. 避免消息丢失
- ​**交换机持久化**​
- ​**队列持久化**​
- ​**消息持久化**​
- ​**发布者消息可靠性保障**​
    - ​**事务**​
        - 阻塞式，性能极差 → 不推荐使用
    - ​**发布者确认**​
        - Broker 异步回调通知，推荐异步
            - 同步方式：waitForConfirms()，依然会阻塞
            - 异步方式：ConfirmListener
    - 本地消息表或者使用缓存，注意业务幂等性处理
- ​**Broker 消息可靠性保障**​
    - 高可用架构，避免单点故障
        - 镜像队列
        - Quorum Queues
    - rabbitmq.conf 的消息刷盘策略 0：每条消息都刷盘
    - 如果一条消息的 Routing Key 没有匹配任何队列的 Binding Key，这条消息会被直接丢弃。
- ​**消费端可靠性保障**​
    - 手动 ACK 且业务处理成功后才确认
    - 设置死信队列

### 3. 信道属性修改限制
- 一旦设定就不可动态切换（qos 预取值除外。qos：调整消息流速）