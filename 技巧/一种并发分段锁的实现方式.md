


```java
// 伪代码展示Caffeine并发加载原理
ConcurrentMap<Key, Lock> keyLocks = new ConcurrentHashMap<>();

public V get(Key key) {
    V value = cache.getIfPresent(key);
    if (value != null) return value;
// 每个Key独立加锁（分段锁思想）
    Lock lock = keyLocks.computeIfAbsent(key, k -> new ReentrantLock());
    lock.lock();
    try {
        // 双重检查（避免重复加载）
        value = cache.getIfPresent(key);
        if (value == null) {
            value = loadFromDB(key);  // ⚠️ 实际查询DB
            cache.put(key, value);
        }
        return value;
    } finally {
        lock.unlock();
        keyLocks.remove(key);  // 释放锁
    }
```

- **Key粒度锁**：每个失效Key对应独立锁（`ReentrantLock`实现）
- **线程挂起**：竞争线程**挂起等待**（非CAS自旋），避免CPU空转
- **锁分段优化**：类似ConcurrentHashMap的分段锁思想，减少竞争

